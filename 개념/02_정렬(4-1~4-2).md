# 정렬



## 💭 버블 정렬

---

> 이웃하는 숫자를 비교해 작은 수를 앞으로 이동시키는 과정을 반복해 정렬
> 

한 비교가 끝날 때마다 가장 큰 수가 배열의 가장 마지막에 정렬된다.

![Untitled](https://user-images.githubusercontent.com/72641395/182876311-e4c4c236-0270-4be3-b3b7-56591abc18a7.png)

1. 비교 연산이 필요한 루프 범위를 설정한다.

2. 인접한 데이터 값을 비교한다.

3. swap 조건에 부합하면 swap 연산을 수행한다.

4. 루프 범위가 끝날 때까지 1 ~ 3을 반복한다.

5. 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.

6. 비교 대상이 없을 때까지 1 ~ 5 를 반복한다.

   

- **Java code**
  
    ```java
    // BubbleSort
    
    for (int i = 0; i < N - 1; i++) {
    		for (int j = 0; j < N -1; j++) {
    				// 앞과 뒤의 값을 비교해 위치를 swap
    				if (A[j] > A[j+1]) {
    						int temp = A[j];
    						A[j] = A[j+1];
    						A[j+1] = temp;
    				}
    		}
    }
    ```
    
  
  
- **Time Complexity**
  
    버블 정렬의 총 비교 횟수는 $(n-1) + (n-2)+...+1 = n(n-1)/2$
    
    안쪽 루프의 if 조건이 True 일 경우 자리 바꿈은 $O(1)$ 시간.
    
    ⇒ 최종 시간 복잡도: $O(n^2) * O(1) = O(n^2)$
    
    

## 🔍 선택 정렬

---

> 입력 배열 전체에서 최솟값을 선택해 배열의 0번 원소와 자리를 바꿔 나간다.
> 

한 비교가 끝날 때마다 가장 작은 수가 배열의 가장 앞에 정렬된다.

![Untitled 1](https://user-images.githubusercontent.com/72641395/182876289-9cbb4235-a22c-4d8c-8969-89789df83202.png)

1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.

2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap 한다.

3. 가장 앞에 있는 데이터의 위치를 변경해 남은 정렬 부분의 범위를 축소한다.

4. 전체 데이터 크기만큼 index가 커질 때까지, 남은 정렬 부분이 없을 때까지 반복한다.

   

- **Algorithm**
  
    ```java
    SelectionSort
    
    for (int i = 0; i < str.length(); i++) {
    		int min = i;
    		// 최솟값을 가지는 인덱스를 찾기
    		for (int j = i + 1; j < str.length(); j++) {
    				if (A[j] < A[min]) min = j;
    		}
    		// i번째 값과 최솟값을 교환
    		swap(A, min, i);
    }
    ```
    
  
  
- **Time Complexity**
  
    선택 정렬의 총 비교 횟수는 $(n-1) + (n-2)+...+1 = n(n-1)/2$
    
    안쪽 루프의 if 조건이 True 일 경우 자리 바꿈은 $O(1)$ 시간.
    
    ⇒ 최종 시간 복잡도: $O(n^2) * O(1) = O(n^2)$
    
  
  
- **특징**
    
    - 입력의 정렬 상태에 상관 없이 항상 일정한 시간 복잡도를 갖고, 입력에 민감하지 않다.
    - 원소 간의 자리 바꿈 횟수가 최소인 정렬이다.